
Service oriented computing~\cite{Papazoglou2007} is at the origin of an evolution in the field of software development.
Service oriented methods advocates for the construction of software systems formed by the composition of heterogeneous, loosely coupled modules.
These modules (or services) communicate in order to achieve a common purpose.
 
An important challenge of service oriented development is  to ensure the alignment between the requirements imposed by the business logic and the IT systems actually being developed.
(Moreover, IT systems need to evolve according to the business needs.)
Thus, organizations are seeking for mechanisms to bridge the gap between the actually developed systems and their business needs~\cite{bell}. 
The literature stresses the need for methodologies and techniques for service oriented analysis and design, claiming that they are the cornerstone in the development of meaningful service based applications~\cite{5}.  

In Service-Oriented Computing, pre-existing services are
combined to produce applications and provide the business logic. 
The selection of services is usually guided by the \textit{functional} requirements of the application being developed~\cite{1,2,decastro1,PapazoglouH06}. 
(Functional properties of a computer system are characterized by the effect produced by the system when given a defined input.)
Functional properties are not the only crucial aspect in the software development process. 
Other properties need to be addressed to fit in the application with its context.
These other aspects are called Non-Functional Properties.

Non-functional aspects of the services, often expressed as requirements and constraints in general purpose methodologies, are not usually considered from the early phases of the (service) software process.
Most methods consider them only after the application has been implemented, in order to ensure some level of reliability (e.g., data privacy, exception handling, atomicity, data persistence). 
This leads to service based applications that are partly specified and, thereby, partly compliant with the requirements of the application.
Ideally, non-functional requirements should be considered along with all the stages of the software development. 
The adoption of non-functional specifications from the early states of development
can help the developer to produce applications that are capable of dealing with
the application context.

\bigskip

Model Driven Development (MDD) is a top-down approach for the development of software systems. 
The main ideas of MDD were originally proposed by the Object Management Group (OMG)~\cite{mda}, as a set of guidelines for the structuring of specifications.
The technique advocates for the use of \textit{models} to specify a software system at different levels of abstraction (called \textit{viewpoints}). 
These models are successively refined from abstract specifications into actual computer programs.

In this context, we argue that the convergence of model-driven software development, service orientation and better techniques for documenting and improving business processes are key to make real the idea of rapid, accurate development of software that serves, rather than dictates the needs of its users~\cite{watson}. 

In this work, we are interested in the extension of the \textit{Service Oriented Development Method} (SOD-M)~\cite{decastro1}, to support non-functional aspects, from the early stages of software development.
SOD-M is aligned with the MDD directives and proposes models, practices and techniques for the development of service-based applications.
SOD-M does not provide support for the specification of non-functional requirements, such as
security, reliability, and efficiency. 

The main goals of our work are:
\begin{trivlist}
\item \textit{(i)} To define a NFR model including a set of concepts need for the modeling of NFR in service-oriented applications.
\item \textit{(ii)} To propose a methodology for supporting the construction of service-oriented applications, taking into account both functional and non-functional requirements;
\item \textit{(iii)} To improve the construction process by providing an abstract view of the application and ensure the conformance to its specification;
\item \textit{(iv)} To reduce the programming effort through the semi-automatic generation of  models for the application, to produce concrete implementations from high abstraction models;
\end{trivlist}

The rest of the paper is organized as follows. 
Section\dots





