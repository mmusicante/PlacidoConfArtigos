
%Service oriented computing is at the origin of an evolution in the field of software development.
%Service oriented methods advocates for the construction of software systems formed by the composition of heterogeneous, loosely coupled modules.
%These modules (or services) communicate in order to achieve a common purpose.


%(Moreover, IT systems need to evolve according to the business needs.)
%Thus, organizations are seeking for mechanisms to bridge the gap between the actually developed systems and their business needs~\cite{bell}.


In Service-Oriented Computing~\cite{Papazoglou2007}, pre-existing services are
composed to build an application business logic.
The selection of services is usually guided by the \textit{functional} requirements of the application being developed~\cite{1,2,decastro1,PapazoglouH06}\footnote{Functional properties of a computer system are characterized by the effect produced by the system when given a defined input.}.
An important challenge of service oriented development is  to ensure the alignment between the functional requirements imposed by the business logic and the functions actually being developed.

Functional properties are not the only  aspect in the software development process.
Non-functional properties need to be addressed to fit in the application for example  data privacy, exception handling, atomicity  and, data persistence.
Adding non-functional properties and respecting services constraints while composing services is a complex task that implies programming  protocols for instance authentication protocols to call a service, and atomicity (exception handling and recovery) for ensuring a true synchronization of the results produced by the service methods calls.

Even if service oriented computing promotes ease of information systems construction thanks to services reuse. This is not applied to non-functional constraints because they do not follow  the same service oriented principle. 
%
%Furthermore,  often they are  not fully considered in the specification process of existing services' oriented development methods. Rather, 
%They   are either ensured by the underlying execution platform, or they are programmed through ad-hoc protocols once the application has been programmed. 
Ideally, non-functional requirements should be considered in every phase of the software development.
Yet,  they are partially or rarely methodologically derived from the application specification, and they are added once the code has been implemented. In consequence, the resulting application does not fully preserve the compliance and reuse expectations provided by the service oriented computing methods.


%Yet, non-functional properties of  services, often expressed as requirements and constraints in general purpose methodologies, are not usually considered from the early phases of the (service) software process.
%Most methods integrate them only after the application has been implemented.
%This leads to service based applications that are partialy specified and, thereby, partialy compliant with the requirements of the application.

% song title disseminated in the walls of the user's Facebook and Twitter accounts. 



%The adoption of non-functional specifications from the early states of development can help the developer to produce applications that  can deal with the application context.

The literature stresses the need for methodologies and techniques for service oriented analysis and design 
%since they are the cornerstone in the development of meaningful service based applications
~\cite{5}. Existing approaches argue that the convergence of model-driven software development, service orientation,   and  business processes improvement are key for developing accurate  software 
%that serves, rather than dictates the needs of its users
~\cite{watson}. Model Driven Development (MDD)  for the development of software systems is mainly characterized by the use of models as a product \cite{Selic03}.
%The main ideas of MDD were originally proposed by the Object Management Group (OMG) whit their proposal of a Model Driven Architecture (MDA)~\cite{miller}. 
%
% (called \textit{viewpoints}).
These models are successively refined from abstract specifications into actual computer programs.

Our work proposes  the $\pi$-\textit{ Service Oriented Development Method} ($\pi$-SODM)
%~\cite{decastro1}, 
to support non-functional aspects of service-oriented applications, taking into account both functional and non-functional requirements from the early stages of software development.
$\pi$-SODM is aligned with the MDD directives and proposes models, practices and techniques for the development of service-based applications.  The technique promotes  the use of \textit{models} to specify a software system at different levels of abstraction. Models are organized according to the guidelines for structuring the specifications of software systems of the Model Driven Architecture (MDA)~\cite{miller} approach. The objective of  $\pi$-SODM are to:
%SOD-M does not provide support for the specification of non-functional requirements, such as
%security, reliability, and efficiency.
\begin{trivlist}
\item \textit{(i)} Improve the construction process by providing an abstract view of the application and ensure the conformance to its specification;
\item \textit{(ii)} Reduce the programming effort through the semi-automatic generation of  models for the application, to produce concrete implementations from high abstraction models.
\end{trivlist}

%The main contribution of our work is a methodology for supporting the construction of service-oriented applications, 

 This paper describes the methodology $\pi$-SODM based on  an NFP model including a set of concepts  for  modeling  NFP in service-oriented applications.
Accordingly, the remainder of the paper is organized as follows.
Section\ref{sec:relworks} summarizes the general principles of existing works for addressing NFP and associating them to service compositions. Section \ref{sec:motivation} introduces the meta-models of the $\pi$-SODM and transformation rules. Section \ref{sec:implementation} describes the $\pi$-SODM environment that provides tools for building service based applications according to the $\pi$-SODM methodology. Section\ref{sec:flyingPig} describes the experiment that we conducted for validating our methodology and discusses lessons learned. Finally, Section \ref{sec:conclusions} concludes the paper and gives research perspectives.





